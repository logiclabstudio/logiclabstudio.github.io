<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Business Card Generator — Pro</title>
  <meta name="description" content="Design professional business cards in your browser. Export print-ready PNG with bleed, trim, and safe guides." />
  <style>
    :root{
      --bg:#070a12;
      --panel:#0f172a;
      --card:#0b1020;
      --muted:#97a6bf;
      --text:#e8eefc;
      --line:rgba(255,255,255,.12);
      --line2:rgba(255,255,255,.08);
      --accent:#60a5fa;
      --accent2:#a78bfa;
      --good:#22c55e;
      --warn:#fbbf24;

      --radius:16px;
      --radius2:18px;
      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --shadow2: 0 10px 30px rgba(0,0,0,.35);

      --focus: 0 0 0 4px rgba(96,165,250,.25);

      /* UI sizing */
      --sidebar: 420px;
      --max: 1280px;

      /* Theme defaults (editable) */
      --t_bg1:#0b1020;
      --t_bg2:#111827;
      --t_text:#e5e7eb;
      --t_accent:#60a5fa;
      --t_muted:rgba(229,231,235,.82);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:
        radial-gradient(1200px 700px at 15% -10%, rgba(96,165,250,.20), transparent 55%),
        radial-gradient(900px 600px at 110% 10%, rgba(167,139,250,.18), transparent 55%),
        radial-gradient(900px 600px at 60% 120%, rgba(34,197,94,.12), transparent 55%),
        linear-gradient(180deg, #070a12, #070a12);
      color:var(--text);
      overflow-x:hidden;
    }
    a{color:inherit}
    button, input, select, textarea{font:inherit}
    .sr-only{
      position:absolute; width:1px; height:1px;
      padding:0; margin:-1px; overflow:hidden;
      clip:rect(0,0,0,0); border:0;
    }

    /* Topbar */
    .topbar{
      position:sticky; top:0; z-index:50;
      backdrop-filter: blur(10px);
      background: rgba(7,10,18,.55);
      border-bottom:1px solid rgba(255,255,255,.08);
    }
    .topbarInner{
      max-width: var(--max);
      margin:0 auto;
      padding: 12px 16px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .brand{
      display:flex; align-items:center; gap:12px;
      min-width: 240px;
    }
    .logoMark{
      width:38px; height:38px; border-radius: 14px;
      background: radial-gradient(circle at 30% 30%, rgba(96,165,250,.95), rgba(167,139,250,.85));
      box-shadow: 0 10px 30px rgba(96,165,250,.15);
      position:relative;
      overflow:hidden;
    }
    .logoMark:after{
      content:"";
      position:absolute; inset:-20%;
      background: radial-gradient(circle at 25% 25%, rgba(255,255,255,.35), transparent 55%);
      transform: rotate(18deg);
    }
    .brandText{display:flex; flex-direction:column; line-height:1.15}
    .brandText strong{font-weight:900; letter-spacing:.2px; font-size:14px}
    .brandText span{color:var(--muted); font-size:12px}

    .topActions{
      display:grid;
      grid-template-columns: repeat(2, minmax(150px, 1fr));
      gap:8px;
      min-width: min(520px, 55vw);
    }
    .topActions .btn{justify-content:center}
    .topActions .btnPrimary{grid-column: span 2;}
    @media (max-width: 900px){
      .topActions{
        min-width: 0;
        grid-template-columns: 1fr;
        width: 100%;
      }
      .topActions .btnPrimary{grid-column: auto;}
    }

    /* Buttons */
    .btn{
      cursor:pointer;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 12px;
      border-radius: 12px;
      font-weight:800;
      transition: transform .06s ease, background .2s ease, border-color .2s ease, box-shadow .2s ease;
      display:inline-flex; align-items:center; gap:10px;
      user-select:none;
    }
    .btn:hover{background: rgba(255,255,255,.10); border-color: rgba(255,255,255,.22);}
    .btn:active{transform: translateY(1px);}
    .btn:focus{outline:none; box-shadow: var(--focus);}
    .btnPrimary{
      background: linear-gradient(135deg, rgba(96,165,250,.95), rgba(167,139,250,.88));
      border-color: rgba(255,255,255,.20);
      color:#081025;
    }
    .btnDanger{
      background: rgba(251,113,133,.12);
      border-color: rgba(251,113,133,.35);
      color: #ffd0d8;
    }
    .btnIcon{
      width:18px; height:18px; display:inline-block;
      background: currentColor; border-radius: 5px;
      mask-size: contain; mask-repeat:no-repeat; mask-position:center;
      -webkit-mask-size: contain; -webkit-mask-repeat:no-repeat; -webkit-mask-position:center;
    }
    .i-download{ -webkit-mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="black"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v10m0 0l4-4m-4 4l-4-4M4 17v3h16v-3"/></svg>'); mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="black"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v10m0 0l4-4m-4 4l-4-4M4 17v3h16v-3"/></svg>');}
    .i-share{ -webkit-mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="black"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 12v7a1 1 0 001 1h14a1 1 0 001-1v-7M16 6l-4-4-4 4M12 2v14"/></svg>'); mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="black"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 12v7a1 1 0 001 1h14a1 1 0 001-1v-7M16 6l-4-4-4 4M12 2v14"/></svg>');}
    .i-magic{ -webkit-mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="black"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.5 3l.5 2.5L17.5 6l-2.5.5L14.5 9l-.5-2.5L11.5 6l2.5-.5L14.5 3zM6.5 8l.5 2.5L9.5 11l-2.5.5L6.5 14l-.5-2.5L3.5 11l2.5-.5L6.5 8zM15 12l1 5 5 1-5 1-1 5-1-5-5-1 5-1 1-5z"/></svg>'); mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="black"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.5 3l.5 2.5L17.5 6l-2.5.5L14.5 9l-.5-2.5L11.5 6l2.5-.5L14.5 3zM6.5 8l.5 2.5L9.5 11l-2.5.5L6.5 14l-.5-2.5L3.5 11l2.5-.5L6.5 8zM15 12l1 5 5 1-5 1-1 5-1-5-5-1 5-1 1-5z"/></svg>');}

    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding:6px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      color:var(--muted);
      font-size:12px;
      font-weight:700;
    }

    /* Layout */
    .shell{
      max-width: var(--max);
      margin:0 auto;
      padding: 16px;
      display:grid;
      grid-template-columns: var(--sidebar) 1fr;
      gap:16px;
      align-items:start;
    }
    @media (max-width: 1100px){
      :root{ --sidebar: 100%; }
      .shell{grid-template-columns: 1fr;}
    }

    /* Panels */
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--radius2);
      box-shadow: var(--shadow2);
      overflow:hidden;
    }
    .panel header{
      padding:14px 16px;
      border-bottom:1px solid rgba(255,255,255,.10);
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      background: rgba(255,255,255,.03);
    }
    .panel header .title{
      display:flex;flex-direction:column;gap:2px;
    }
    .panel header h2{
      font-size:13px;margin:0;font-weight:900;letter-spacing:.2px;
    }
    .panel header p{
      margin:0;font-size:12px;color:var(--muted);
    }
    .content{padding:14px 16px;}

    /* Tabs */
    .tabs{
      display:flex; gap:8px; flex-wrap:wrap;
      padding: 10px 16px;
      border-bottom:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.02);
    }
    .tab{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      color: var(--muted);
      padding:8px 10px;
      border-radius: 999px;
      font-weight:900;
      font-size:12px;
      cursor:pointer;
      transition:.2s ease;
    }
    .tab[aria-selected="true"]{
      color:#09122a;
      border-color: rgba(255,255,255,.20);
      background: linear-gradient(135deg, rgba(96,165,250,.95), rgba(167,139,250,.88));
    }

    .grid{display:grid;gap:10px;}
    .row{display:grid;grid-template-columns: 1fr 1fr; gap:10px;}
    @media (max-width: 520px){ .row{grid-template-columns:1fr;} }
    .actionBlock{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      border-radius: 14px;
      padding: 12px;
      display:grid;
      gap:10px;
    }
    .actionBlock h4{
      margin:0;
      font-size:12px;
      letter-spacing:.2px;
      text-transform:uppercase;
      color:var(--muted);
    }
    .actionGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .actionGrid .btn{
      width:100%;
      justify-content:center;
      text-align:center;
    }
    .actionSingle .btn{
      width:100%;
      justify-content:center;
    }
    @media (max-width: 560px){
      .actionGrid{ grid-template-columns: 1fr; }
    }

    label{display:block;font-size:12px;color:var(--muted);margin:0 0 6px;font-weight:800;letter-spacing:.2px;}
    .help{color: rgba(151,166,191,.9); font-size:12px; margin-top:6px; line-height:1.35;}
    input[type="text"], input[type="email"], input[type="url"], input[type="tel"], select, textarea{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(17,24,39,.55);
      color:var(--text);
      outline:none;
      transition: .15s ease;
    }
    textarea{min-height: 70px; resize: vertical;}
    input:focus, select:focus, textarea:focus{box-shadow: var(--focus); border-color: rgba(96,165,250,.35);}
    input[type="color"]{
      width:100%;
      height:40px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: transparent;
      padding:0;
    }
    .inline{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      border-radius: 12px;
      padding:8px 10px;
      font-size:12px; color: var(--muted);
      font-weight:800;
    }
    .chip input{transform: scale(1.1);}

    .divider{height:1px;background: rgba(255,255,255,.10); margin:12px 0;}

    /* Preview */
    .previewWrap{
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:14px;
    }
    .previewTop{
      display:flex;align-items:flex-end;justify-content:space-between;gap:12px;flex-wrap:wrap;
    }
    .canvasRow{
      display:flex;
      gap:16px;
      flex-wrap:wrap;
      align-items:flex-start;
    }
    .cardFrame{
      background: rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.12);
      border-radius: 18px;
      padding:14px;
      box-shadow: var(--shadow);
      flex: 1 1 360px;
      min-width: 320px;
    }
    .cardFrame h3{
      margin:0 0 10px;font-size:12px;color:var(--muted);font-weight:900;letter-spacing:.4px;
      text-transform:uppercase;
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
    }
    canvas{
      display:block;
      border-radius: 14px;
      background: transparent;
      max-width: 100%;
      height: auto;
    }
    .smallNote{font-size:12px;color:var(--muted);}

    /* Toast */
    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(17,24,39,.92);
      border:1px solid rgba(255,255,255,.14);
      box-shadow: var(--shadow2);
      border-radius: 14px;
      padding: 10px 12px;
      color: var(--text);
      display:flex;
      align-items:center;
      gap:10px;
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      z-index: 1000;
      max-width: min(92vw, 520px);
    }
    .toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(-2px);
    }
    .dot{
      width:10px;height:10px;border-radius:999px;background: var(--good);
      box-shadow: 0 0 0 4px rgba(34,197,94,.12);
      flex:none;
    }
    .dot.warn{background: var(--warn); box-shadow: 0 0 0 4px rgba(251,191,36,.12);}
    .toast strong{font-weight:900}
    .toast span{color: var(--muted); font-size:12px}

    /* Modal */
    .modalBack{
      position:fixed; inset:0; z-index:999;
      background: rgba(0,0,0,.65);
      display:none;
      align-items:center; justify-content:center;
      padding: 16px;
    }
    .modalBack.open{display:flex;}
    .modal{
      width: min(720px, 98vw);
      background: rgba(15,23,42,.92);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .modal header{
      padding:14px 16px;
      border-bottom:1px solid rgba(255,255,255,.12);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      background: rgba(255,255,255,.03);
    }
    .modal header h3{margin:0; font-size:13px; font-weight:900;}
    .modal .body{padding: 14px 16px;}
    .modal .body p{margin: 0 0 10px; color: var(--muted); font-size:13px; line-height:1.5}
    .kbd{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-weight:900;
      font-size:12px;
      color: var(--text);
    }

    /* Hide sections */
    .tabPanel{display:none;}
    .tabPanel.active{display:block;}
  </style>
</head>

<body>
  <!-- TOP BAR -->
  <div class="topbar">
    <div class="topbarInner">
      <div class="brand">
        <div class="logoMark" aria-hidden="true"></div>
        <div class="brandText">
          <strong>Business Card Generator</strong>
          <span>Pro layout • templates • QR • export</span>
        </div>
      </div>

      <div class="topActions">
        <button class="btn" id="openHelp" type="button"><span class="btnIcon i-magic"></span>Shortcuts</button>
        <button class="btn" id="savePreset" type="button">Save preset</button>
        <button class="btn" id="loadPreset" type="button">Load preset</button>
        <button class="btn btnPrimary" id="downloadFrontTop" type="button"><span class="btnIcon i-download"></span>Export Front</button>
      </div>
    </div>
  </div>

  <main class="shell">
    <!-- LEFT: CONTROLS -->
    <section class="panel" aria-label="Controls">
      <header>
        <div class="title">
          <h2>Design Controls</h2>
          <p>Use tabs to edit content, style, logo, and export.</p>
        </div>
        <span class="pill" id="statusPill">Ready</span>
      </header>

      <div class="tabs" role="tablist" aria-label="Editor tabs">
        <button class="tab" role="tab" aria-selected="true" aria-controls="tab-content" id="t-content">Content</button>
        <button class="tab" role="tab" aria-selected="false" aria-controls="tab-style" id="t-style">Style</button>
        <button class="tab" role="tab" aria-selected="false" aria-controls="tab-logo" id="t-logo">Logo & QR</button>
        <button class="tab" role="tab" aria-selected="false" aria-controls="tab-export" id="t-export">Export</button>
      </div>

      <div class="content">

        <!-- CONTENT TAB -->
        <section id="tab-content" class="tabPanel active" role="tabpanel" aria-labelledby="t-content">
          <div class="grid">
            <div class="row">
              <div>
                <label for="company">Company</label>
                <input id="company" type="text" value="Your Company Name" autocomplete="organization"/>
              </div>
              <div>
                <label for="tagline">Tagline</label>
                <input id="tagline" type="text" value="Your Service Tagline" />
              </div>
            </div>

            <div class="row">
              <div>
                <label for="name">Full name</label>
                <input id="name" type="text" value="Your Full Name" autocomplete="name"/>
              </div>
              <div>
                <label for="title">Role / Title</label>
                <input id="title" type="text" value="Your Role / Title" />
              </div>
            </div>

            <div class="row">
              <div>
                <label for="phone">Phone</label>
                <input id="phone" type="tel" value="+1 (555) 123-4567" autocomplete="tel"/>
              </div>
              <div>
                <label for="email">Email</label>
                <input id="email" type="email" value="hello@yourdomain.com" autocomplete="email"/>
              </div>
            </div>

            <div class="row">
              <div>
                <label for="website">Website</label>
                <input id="website" type="url" value="yourcompany.com" autocomplete="url"/>
              </div>
              <div>
                <label for="address">Address</label>
                <input id="address" type="text" value="City, State / Country" autocomplete="street-address"/>
              </div>
            </div>

            <div>
              <label for="backBullets">Back side bullet points (one per line)</label>
              <textarea id="backBullets">Primary Service 01
Primary Service 02
Primary Service 03
Primary Service 04</textarea>
              <div class="help">These show as bulleted highlights on the back card.</div>
            </div>

            <div class="row">
              <div>
                <label for="linkedin">LinkedIn</label>
                <input id="linkedin" type="url" value="linkedin.com/in/yourprofile" />
              </div>
              <div>
                <label for="instagram">Instagram</label>
                <input id="instagram" type="text" value="@yourhandle" />
              </div>
            </div>

            <div class="divider"></div>

            <div class="row">
              <div>
                <label for="layout">Layout template</label>
                <select id="layout">
                  <option value="classic">Guidance Template A (left info, right logo)</option>
                  <option value="split">Guidance Template B (logo top, info bottom)</option>
                  <option value="minimal">Guidance Template C (clean + airy)</option>
                  <option value="centered">Guidance Template D (brand focused)</option>
                </select>
                <div class="help">Templates change typography + placement. You can still drag the logo.</div>
              </div>
              <div>
                <label for="icons">Contact icons</label>
                <select id="icons">
                  <option value="on">On</option>
                  <option value="off">Off</option>
                </select>
                <div class="help">Icons are drawn on the canvas (no external libraries).</div>
              </div>
            </div>
          </div>
        </section>

        <!-- STYLE TAB -->
        <section id="tab-style" class="tabPanel" role="tabpanel" aria-labelledby="t-style">
          <div class="grid">
            <div class="row">
              <div>
                <label for="size">Card size</label>
                <select id="size">
                  <option value="us">US 3.5 × 2 in</option>
                  <option value="eu">85 × 55 mm</option>
                </select>
              </div>
              <div>
                <label for="dpi">DPI (export quality)</label>
                <select id="dpi">
                  <option value="300">300 (print)</option>
                  <option value="200">200</option>
                  <option value="150">150</option>
                </select>
              </div>
            </div>

            <div class="row">
              <div>
                <label for="font">Font</label>
                <select id="font">
                  <option value="system">System</option>
                  <option value="inter">Inter-like</option>
                  <option value="mono">Mono</option>
                  <option value="serif">Serif</option>
                </select>
              </div>
              <div>
                <label for="radius">Corner roundness</label>
                <select id="radius">
                  <option value="18">Rounded</option>
                  <option value="12">Medium</option>
                  <option value="6">Sharp</option>
                </select>
              </div>
            </div>

            <div class="divider"></div>

            <div class="row">
              <div>
                <label for="bg1">Background 1</label>
                <input id="bg1" type="color" value="#0b1020" />
              </div>
              <div>
                <label for="bg2">Background 2</label>
                <input id="bg2" type="color" value="#111827" />
              </div>
            </div>

            <div class="row">
              <div>
                <label for="accent">Accent</label>
                <input id="accent" type="color" value="#60a5fa" />
              </div>
              <div>
                <label for="text">Text</label>
                <input id="text" type="color" value="#e5e7eb" />
              </div>
            </div>

            <div class="divider"></div>

            <div class="row">
              <div>
                <label for="preset">Color presets</label>
                <select id="preset">
                  <option value="custom">Custom</option>
                  <option value="midnight">Midnight Blue</option>
                  <option value="mono">Mono Black</option>
                  <option value="sunset">Sunset</option>
                  <option value="emerald">Emerald</option>
                </select>
                <div class="help">Pick a professional starting point, then tweak.</div>
              </div>
              <div>
                <label>Guides</label>
                <div class="inline">
                  <span class="chip"><input id="guides" type="checkbox" checked /> Show print guides</span>
                  <span class="chip"><input id="backSide" type="checkbox" /> Enable back side</span>
                </div>
                <div class="help">Guides show bleed + trim + safe area.</div>
              </div>
            </div>

            <div class="row">
              <div>
                <label for="texture">Background texture</label>
                <select id="texture">
                  <option value="soft" selected>Soft glow</option>
                  <option value="mesh">Mesh pattern</option>
                  <option value="grid">Micro grid</option>
                  <option value="none">None</option>
                </select>
              </div>
              <div>
                <label for="backStyle">Back style</label>
                <select id="backStyle">
                  <option value="ring" selected>Ring + centered logo</option>
                  <option value="stripe">Diagonal stripe</option>
                  <option value="minimal">Minimal clean</option>
                </select>
              </div>
            </div>

            <div class="divider"></div>

            <div class="row">
              <div>
                <label for="backCompanyColor">Back company color</label>
                <input id="backCompanyColor" type="color" value="#e5e7eb" />
              </div>
              <div>
                <label for="backTaglineColor">Back tagline color</label>
                <input id="backTaglineColor" type="color" value="#cbd5e1" />
              </div>
            </div>
            <div class="row">
              <div>
                <label for="backWebsiteColor">Back website color</label>
                <input id="backWebsiteColor" type="color" value="#60a5fa" />
              </div>
              <div>
                <label for="backBulletColor">Back bullet text color</label>
                <input id="backBulletColor" type="color" value="#e5e7eb" />
              </div>
            </div>
            <div class="row">
              <div>
                <label for="backBulletDotColor">Back bullet dot color</label>
                <input id="backBulletDotColor" type="color" value="#60a5fa" />
              </div>
              <div></div>
            </div>
          </div>
        </section>

        <!-- LOGO + QR TAB -->
        <section id="tab-logo" class="tabPanel" role="tabpanel" aria-labelledby="t-logo">
          <div class="grid">
            <div class="row">
              <div>
                <label for="logo">Logo (PNG/JPG/SVG)</label>
                <input id="logo" type="file" accept="image/*,.svg" />
                <div class="help">Drag on the card. Scroll to resize. <span class="kbd">Shift</span> = faster drag.</div>
              </div>
              <div>
                <label for="logoMode">Logo style</label>
                <select id="logoMode">
                  <option value="plate">Plate (recommended)</option>
                  <option value="none">No plate</option>
                </select>
                <div class="help">Plate keeps logos readable on gradients.</div>
              </div>
            </div>

            <div class="divider"></div>

            <div class="row">
              <div>
                <label for="qrMode">QR code</label>
                <select id="qrMode">
                  <option value="off">Off</option>
                  <option value="website">Website</option>
                  <option value="email">Email</option>
                  <option value="phone">Phone</option>
                  <option value="vcard">vCard (best)</option>
                </select>
                <div class="help">vCard lets people save contact directly.</div>
              </div>
              <div>
                <label for="qrSize">QR size</label>
                <select id="qrSize">
                  <option value="0.18">Small</option>
                  <option value="0.24" selected>Medium</option>
                  <option value="0.30">Large</option>
                </select>
                <div class="help">Placed bottom-right. Auto-contrasted.</div>
              </div>
            </div>

            <div class="row">
              <div>
                <label for="qrLabel">QR label (optional)</label>
                <input id="qrLabel" type="text" value="Scan to save contact" />
              </div>
              <div>
                <label for="qrOnBack">Place QR on</label>
                <select id="qrOnBack">
                  <option value="front">Front</option>
                  <option value="back">Back</option>
                </select>
              </div>
            </div>

            <div class="row">
              <div>
                <label for="qrDark">QR dark color</label>
                <input id="qrDark" type="color" value="#000000" />
              </div>
              <div>
                <label for="qrLight">QR light color</label>
                <input id="qrLight" type="color" value="#ffffff" />
              </div>
            </div>
          </div>
        </section>

        <!-- EXPORT TAB -->
        <section id="tab-export" class="tabPanel" role="tabpanel" aria-labelledby="t-export">
          <div class="grid">
            <div class="actionBlock">
              <h4>File Settings</h4>
              <div class="row">
                <div>
                  <label for="exportMode">Export mode</label>
                  <select id="exportMode">
                    <option value="withBleed" selected>With bleed (recommended)</option>
                    <option value="trimOnly">Trim only (no bleed)</option>
                  </select>
                  <div class="help">Print shops usually prefer bleed.</div>
                </div>
                <div>
                  <label for="fileName">File base name</label>
                  <input id="fileName" type="text" value="business-card" />
                </div>
              </div>
            </div>

            <div class="actionBlock">
              <h4>Quick Exports</h4>
              <div class="actionGrid">
                <button class="btn btnPrimary" id="downloadFront" type="button"><span class="btnIcon i-download"></span>Front PNG</button>
                <button class="btn" id="downloadBack" type="button"><span class="btnIcon i-download"></span>Back PNG</button>
                <button class="btn" id="downloadVcf" type="button">vCard (.vcf)</button>
                <button class="btn" id="exportSheet" type="button">A4 Sheet PNG</button>
              </div>
            </div>

            <div class="actionBlock">
              <h4>Sheet Print Options</h4>
              <div class="row">
                <div>
                  <label for="sheetSide">Sheet side</label>
                  <select id="sheetSide">
                    <option value="front" selected>Front</option>
                    <option value="back">Back</option>
                    <option value="both">Front + Back</option>
                  </select>
                </div>
                <div>
                  <label for="sheetDpi">Sheet DPI</label>
                  <select id="sheetDpi">
                    <option value="300" selected>300 (print)</option>
                    <option value="200">200</option>
                    <option value="150">150</option>
                  </select>
                </div>
              </div>
            </div>

            <div class="actionBlock">
              <h4>Preset & Sharing</h4>
              <div class="actionGrid">
                <button class="btn" id="savePresetPanel" type="button">Save preset</button>
                <button class="btn" id="loadPresetPanel" type="button">Load preset</button>
                <button class="btn" id="copyLink" type="button"><span class="btnIcon i-share"></span>Copy share link</button>
                <button class="btn btnDanger" id="reset" type="button">Reset all</button>
              </div>
              <div class="help">
                Share link stores your settings in the URL (no server). Presets save to your browser (localStorage).
              </div>
            </div>
          </div>
        </section>

      </div>
    </section>

    <!-- RIGHT: PREVIEW -->
    <section class="panel" aria-label="Preview">
      <header>
        <div class="title">
          <h2>Preview</h2>
          <p>Front + (optional) back • drag logo • scroll to resize</p>
        </div>
        <span class="pill" id="dimLabel">—</span>
      </header>

      <div class="previewWrap">
        <div class="previewTop">
          <div class="smallNote">Preview is scaled. Export uses full DPI resolution.</div>
          <div class="smallNote">Keyboard: <span class="kbd">Ctrl</span>+<span class="kbd">S</span> save preset • <span class="kbd">Ctrl</span>+<span class="kbd">E</span> export front</div>
        </div>

        <div class="canvasRow">
          <div class="cardFrame">
            <h3>
              <span>Front</span>
              <span class="pill" id="frontMeta">—</span>
            </h3>
            <canvas id="front"></canvas>
          </div>

          <div class="cardFrame">
            <h3>
              <span>Back</span>
              <span class="pill" id="backMeta">—</span>
            </h3>
            <canvas id="back"></canvas>
            <div class="smallNote" style="margin-top:8px;">Turn on “Enable back side” to export.</div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- TOAST -->
  <div class="toast" id="toast" role="status" aria-live="polite">
    <div class="dot" id="toastDot"></div>
    <div>
      <strong id="toastTitle">Done</strong><br/>
      <span id="toastMsg">—</span>
    </div>
  </div>

  <!-- HELP MODAL -->
  <div class="modalBack" id="helpModal" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Shortcuts and tips">
      <header>
        <h3>Shortcuts & Tips</h3>
        <button class="btn" id="closeHelp" type="button">Close</button>
      </header>
      <div class="body">
        <p><strong>Drag mode</strong>: You can drag almost any text block, logo, bullets, and QR on both front/back. Scroll over logo to resize. Hold <span class="kbd">Shift</span> to move faster.</p>
        <p><strong>QR</strong>: Set to vCard for best results. It will encode your name, phone, email, website, and address.</p>
        <p><strong>Keyboard</strong>:
          <span class="kbd">Ctrl</span>+<span class="kbd">S</span> save preset,
          <span class="kbd">Ctrl</span>+<span class="kbd">O</span> load preset,
          <span class="kbd">Ctrl</span>+<span class="kbd">E</span> export front,
          <span class="kbd">Esc</span> close this window.
        </p>
        <p><strong>Print</strong>: Use 300 DPI and “With bleed” unless your printer requests otherwise.</p>
        <p><strong>Pro features</strong>: Export an A4 print sheet, download a .vcf contact file, and customize QR dark/light colors.</p>
      </div>
    </div>
  </div>

<script>
(() => {
  // ========= Helpers =========
  const $ = (id) => document.getElementById(id);
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

  function toast(kind, title, msg){
    const t = $("toast");
    const dot = $("toastDot");
    $("toastTitle").textContent = title;
    $("toastMsg").textContent = msg;
    dot.className = "dot" + (kind === "warn" ? " warn" : "");
    t.classList.add("show");
    clearTimeout(toast._t);
    toast._t = setTimeout(()=>t.classList.remove("show"), 2200);
  }

  function safeText(s, max=80){
    s = (s || "").toString();
    if (s.length > max) return s.slice(0, max-1) + "…";
    return s;
  }
  function ensureUrl(s){
    s = (s || "").trim();
    if(!s) return "";
    if (s.startsWith("http://") || s.startsWith("https://")) return s;
    return `https://${s.replace(/^@/,"")}`;
  }

  function fontStack(kind){
    switch(kind){
      case "inter": return "ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      case "mono": return "ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace";
      case "serif": return "ui-serif, Georgia, 'Times New Roman', Times, serif";
      default: return "system-ui, -apple-system, Segoe UI, Roboto, Arial";
    }
  }

  function hexToRgb(hex){
    const h = hex.replace("#","").trim();
    if (h.length === 3){
      const r = parseInt(h[0]+h[0],16);
      const g = parseInt(h[1]+h[1],16);
      const b = parseInt(h[2]+h[2],16);
      return {r,g,b};
    }
    const r = parseInt(h.slice(0,2),16);
    const g = parseInt(h.slice(2,4),16);
    const b = parseInt(h.slice(4,6),16);
    return {r,g,b};
  }

  function luminance(hex){
    const {r,g,b} = hexToRgb(hex);
    const srgb = [r,g,b].map(v=>{
      v/=255;
      return v <= 0.03928 ? v/12.92 : Math.pow((v+0.055)/1.055, 2.4);
    });
    return 0.2126*srgb[0] + 0.7152*srgb[1] + 0.0722*srgb[2];
  }

  function bestTextColor(bgHex){
    // simple contrast: choose near-white or near-black
    return luminance(bgHex) > 0.45 ? "#0b1020" : "#e5e7eb";
  }
  function ensurePos(key){
    if (!state.positions[key]) state.positions[key] = { x: 0, y: 0 };
    return state.positions[key];
  }
  function offsetPx(key, w, h){
    const p = ensurePos(key);
    return { x: p.x * w, y: p.y * h };
  }
  function addHit(side, key, x, y, w, h, type="offset"){
    state.hitRegions[side].push({ key, x, y, w, h, type });
  }

  // ========= Card sizes / export =========
  const SIZES = {
    us: { w_in: 3.5, h_in: 2.0, label: "US 3.5×2 in" },
    eu: { w_in: 3.346, h_in: 2.165, label: "85×55 mm" } // mm → in
  };
  const BLEED_IN = 0.125; // 1/8"
  const SAFE_IN  = 0.125;

  function px(inches, dpi){ return Math.round(inches * dpi); }

  // ========= Elements =========
  const els = {
    // tabs
    tabs: ["t-content","t-style","t-logo","t-export"].map($),
    panels: ["tab-content","tab-style","tab-logo","tab-export"].map($),

    // controls
    company: $("company"),
    tagline: $("tagline"),
    name: $("name"),
    title: $("title"),
    phone: $("phone"),
    email: $("email"),
    website: $("website"),
    address: $("address"),
    backBullets: $("backBullets"),
    linkedin: $("linkedin"),
    instagram: $("instagram"),

    layout: $("layout"),
    icons: $("icons"),

    size: $("size"),
    dpi: $("dpi"),
    font: $("font"),
    radius: $("radius"),
    bg1: $("bg1"),
    bg2: $("bg2"),
    accent: $("accent"),
    text: $("text"),
    preset: $("preset"),
    texture: $("texture"),
    backStyle: $("backStyle"),
    backCompanyColor: $("backCompanyColor"),
    backTaglineColor: $("backTaglineColor"),
    backWebsiteColor: $("backWebsiteColor"),
    backBulletColor: $("backBulletColor"),
    backBulletDotColor: $("backBulletDotColor"),
    guides: $("guides"),
    backSide: $("backSide"),

    logo: $("logo"),
    logoMode: $("logoMode"),

    qrMode: $("qrMode"),
    qrSize: $("qrSize"),
    qrLabel: $("qrLabel"),
    qrOnBack: $("qrOnBack"),
    qrDark: $("qrDark"),
    qrLight: $("qrLight"),

    exportMode: $("exportMode"),
    fileName: $("fileName"),
    sheetSide: $("sheetSide"),
    sheetDpi: $("sheetDpi"),

    // actions
    downloadFront: $("downloadFront"),
    downloadBack: $("downloadBack"),
    downloadVcf: $("downloadVcf"),
    exportSheet: $("exportSheet"),
    downloadFrontTop: $("downloadFrontTop"),
    savePreset: $("savePreset"),
    loadPreset: $("loadPreset"),
    savePresetPanel: $("savePresetPanel"),
    loadPresetPanel: $("loadPresetPanel"),
    copyLink: $("copyLink"),
    reset: $("reset"),

    // preview
    dimLabel: $("dimLabel"),
    frontMeta: $("frontMeta"),
    backMeta: $("backMeta"),
    statusPill: $("statusPill"),
    frontCanvas: $("front"),
    backCanvas: $("back"),

    // modal
    helpModal: $("helpModal"),
    openHelp: $("openHelp"),
    closeHelp: $("closeHelp"),
  };

  // ========= State =========
  const state = {
    logoImg: null,
    logoPos: { x: 0.77, y: 0.24 }, // relative to canvas
    logoScale: 0.22, // relative width fraction of canvas
    dragging: false,
    dragOff: { x: 0, y: 0 },
    dragRegion: null,
    dragCanvas: null,
    dragStart: null,
    positions: {},
    hitRegions: { front: [], back: [] },

    // internally cached QR canvas (per side)
    qrCache: { front: null, back: null, keyFront: "", keyBack: "" }
  };

  // Restore saved logo position (per browser)
  const savedPos = localStorage.getItem("bc_logo_pos_v2");
  if (savedPos) {
    try {
      const p = JSON.parse(savedPos);
      if (p && typeof p.x === "number" && typeof p.y === "number") state.logoPos = p;
    } catch {}
  }

  // ========= Tabs =========
  function setTab(idx){
    els.tabs.forEach((t,i)=>{
      const on = i === idx;
      t.setAttribute("aria-selected", on ? "true" : "false");
      els.panels[i].classList.toggle("active", on);
    });
  }
  els.tabs.forEach((t,i)=> t.addEventListener("click", ()=> setTab(i)));

  // ========= Presets =========
  const COLOR_PRESETS = {
    midnight: { bg1:"#0b1020", bg2:"#111827", accent:"#60a5fa", text:"#e5e7eb" },
    mono:     { bg1:"#05070c", bg2:"#0b0f19", accent:"#ffffff", text:"#ffffff" },
    sunset:   { bg1:"#1a0b1f", bg2:"#101827", accent:"#fb7185", text:"#ffe4ea" },
    emerald:  { bg1:"#071a16", bg2:"#07101a", accent:"#22c55e", text:"#e9fff3" },
  };

  function applyPreset(name){
    if(!COLOR_PRESETS[name]) return;
    const p = COLOR_PRESETS[name];
    els.bg1.value = p.bg1;
    els.bg2.value = p.bg2;
    els.accent.value = p.accent;
    els.text.value = p.text;
    if (name === "mono"){ els.texture.value = "none"; els.backStyle.value = "minimal"; }
    if (name === "sunset"){ els.texture.value = "mesh"; els.backStyle.value = "stripe"; }
    if (name === "emerald"){ els.texture.value = "soft"; els.backStyle.value = "ring"; }
    if (name === "midnight"){ els.texture.value = "grid"; els.backStyle.value = "ring"; }
    toast("ok","Preset applied", name);
    redrawAll();
  }

  // ========= URL Share =========
  function getConfig(){
    return {
      company: els.company.value,
      tagline: els.tagline.value,
      name: els.name.value,
      title: els.title.value,
      phone: els.phone.value,
      email: els.email.value,
      website: els.website.value,
      address: els.address.value,
      backBullets: els.backBullets.value,
      linkedin: els.linkedin.value,
      instagram: els.instagram.value,

      layout: els.layout.value,
      icons: els.icons.value,

      size: els.size.value,
      dpi: +els.dpi.value,
      font: els.font.value,
      radius: +els.radius.value,
      bg1: els.bg1.value,
      bg2: els.bg2.value,
      accent: els.accent.value,
      text: els.text.value,
      texture: els.texture.value,
      backStyle: els.backStyle.value,
      backCompanyColor: els.backCompanyColor.value,
      backTaglineColor: els.backTaglineColor.value,
      backWebsiteColor: els.backWebsiteColor.value,
      backBulletColor: els.backBulletColor.value,
      backBulletDotColor: els.backBulletDotColor.value,
      guides: !!els.guides.checked,
      backSide: !!els.backSide.checked,

      logoMode: els.logoMode.value,
      logoPos: state.logoPos,
      logoScale: state.logoScale,
      positions: state.positions,

      qrMode: els.qrMode.value,
      qrSize: +els.qrSize.value,
      qrLabel: els.qrLabel.value,
      qrOnBack: els.qrOnBack.value,
      qrDark: els.qrDark.value,
      qrLight: els.qrLight.value,

      exportMode: els.exportMode.value,
      fileName: els.fileName.value,
      sheetSide: els.sheetSide.value,
      sheetDpi: +els.sheetDpi.value,
    };
  }

  function setConfig(cfg){
    if(!cfg) return;

    // content
    if (cfg.company != null) els.company.value = cfg.company;
    if (cfg.tagline != null) els.tagline.value = cfg.tagline;
    if (cfg.name != null) els.name.value = cfg.name;
    if (cfg.title != null) els.title.value = cfg.title;
    if (cfg.phone != null) els.phone.value = cfg.phone;
    if (cfg.email != null) els.email.value = cfg.email;
    if (cfg.website != null) els.website.value = cfg.website;
    if (cfg.address != null) els.address.value = cfg.address;
    if (cfg.backBullets != null) els.backBullets.value = cfg.backBullets;
    if (cfg.linkedin != null) els.linkedin.value = cfg.linkedin;
    if (cfg.instagram != null) els.instagram.value = cfg.instagram;

    // style
    if (cfg.layout) els.layout.value = cfg.layout;
    if (cfg.icons) els.icons.value = cfg.icons;

    if (cfg.size) els.size.value = cfg.size;
    if (cfg.dpi) els.dpi.value = String(cfg.dpi);
    if (cfg.font) els.font.value = cfg.font;
    if (cfg.radius) els.radius.value = String(cfg.radius);
    if (cfg.bg1) els.bg1.value = cfg.bg1;
    if (cfg.bg2) els.bg2.value = cfg.bg2;
    if (cfg.accent) els.accent.value = cfg.accent;
    if (cfg.text) els.text.value = cfg.text;
    if (cfg.texture) els.texture.value = cfg.texture;
    if (cfg.backStyle) els.backStyle.value = cfg.backStyle;
    if (cfg.backCompanyColor) els.backCompanyColor.value = cfg.backCompanyColor;
    if (cfg.backTaglineColor) els.backTaglineColor.value = cfg.backTaglineColor;
    if (cfg.backWebsiteColor) els.backWebsiteColor.value = cfg.backWebsiteColor;
    if (cfg.backBulletColor) els.backBulletColor.value = cfg.backBulletColor;
    if (cfg.backBulletDotColor) els.backBulletDotColor.value = cfg.backBulletDotColor;
    if (cfg.guides != null) els.guides.checked = !!cfg.guides;
    if (cfg.backSide != null) els.backSide.checked = !!cfg.backSide;

    // logo
    if (cfg.logoMode) els.logoMode.value = cfg.logoMode;
    if (cfg.logoPos && typeof cfg.logoPos.x === "number" && typeof cfg.logoPos.y === "number") state.logoPos = cfg.logoPos;
    if (cfg.logoScale && typeof cfg.logoScale === "number") state.logoScale = clamp(cfg.logoScale, 0.10, 0.42);
    if (cfg.positions && typeof cfg.positions === "object") state.positions = cfg.positions;

    // qr
    if (cfg.qrMode) els.qrMode.value = cfg.qrMode;
    if (cfg.qrSize) els.qrSize.value = String(cfg.qrSize);
    if (cfg.qrLabel != null) els.qrLabel.value = cfg.qrLabel;
    if (cfg.qrOnBack) els.qrOnBack.value = cfg.qrOnBack;
    if (cfg.qrDark) els.qrDark.value = cfg.qrDark;
    if (cfg.qrLight) els.qrLight.value = cfg.qrLight;

    // export
    if (cfg.exportMode) els.exportMode.value = cfg.exportMode;
    if (cfg.fileName) els.fileName.value = cfg.fileName;
    if (cfg.sheetSide) els.sheetSide.value = cfg.sheetSide;
    if (cfg.sheetDpi) els.sheetDpi.value = String(cfg.sheetDpi);

    setupCanvases();
    redrawAll();
  }

  function encodeShare(cfg){
    const json = JSON.stringify(cfg);
    const b64 = btoa(unescape(encodeURIComponent(json)));
    return b64;
  }

  function decodeShare(b64){
    try{
      const json = decodeURIComponent(escape(atob(b64)));
      return JSON.parse(json);
    }catch{
      return null;
    }
  }

  function copyShareLink(){
    const cfg = getConfig();
    // NOTE: logo image is not embedded (too big). Only position + settings.
    const b64 = encodeShare(cfg);
    const url = new URL(window.location.href);
    url.searchParams.set("c", b64);
    navigator.clipboard.writeText(url.toString()).then(()=>{
      toast("ok","Link copied","Settings saved in URL (logo not included).");
    }).catch(()=>{
      toast("warn","Copy failed","Your browser blocked clipboard.");
    });
  }

  // ========= Setup canvases =========
  function setupCanvases(){
    const size = SIZES[els.size.value];
    const dpi = +els.dpi.value;

    const exportMode = els.exportMode.value;
    const bleed = exportMode === "trimOnly" ? 0 : BLEED_IN;

    const w = px(size.w_in + 2*bleed, dpi);
    const h = px(size.h_in + 2*bleed, dpi);

    els.frontCanvas.width = w;
    els.frontCanvas.height = h;
    els.backCanvas.width = w;
    els.backCanvas.height = h;

    const label = `${size.label} @ ${dpi} DPI (${w}×${h}px ${exportMode === "trimOnly" ? "trim" : "incl. bleed"})`;
    els.dimLabel.textContent = label;
    els.frontMeta.textContent = `${w}×${h}`;
    els.backMeta.textContent = els.backSide.checked ? "Enabled" : "Disabled";
  }

  // ========= Drawing helpers =========
  function roundedRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function linearGradient(ctx, w, h, c1, c2){
    const g = ctx.createLinearGradient(0, 0, w, h);
    g.addColorStop(0, c1);
    g.addColorStop(1, c2);
    return g;
  }

  function drawGuides(ctx, w, h, dpi){
    if(!els.guides.checked) return;
    const exportMode = els.exportMode.value;
    const bleedIn = exportMode === "trimOnly" ? 0 : BLEED_IN;

    const bleed = px(bleedIn, dpi);
    const safe = px(SAFE_IN, dpi);

    if (bleedIn === 0){
      // only safe box when no bleed
      ctx.save();
      ctx.setLineDash([8, 8]);
      ctx.strokeStyle = "rgba(96,165,250,.55)";
      ctx.lineWidth = 2;
      ctx.strokeRect(safe, safe, w-2*safe, h-2*safe);
      ctx.setLineDash([]);
      ctx.fillStyle = "rgba(96,165,250,.85)";
      ctx.font = `bold ${Math.max(18, Math.round(w*0.018))}px ${fontStack("system")}`;
      ctx.fillText("SAFE", safe+10, safe+24);
      ctx.restore();
      return;
    }

    ctx.save();
    // Trim box
    ctx.setLineDash([10, 8]);
    ctx.strokeStyle = "rgba(255,255,255,.35)";
    ctx.lineWidth = 2;
    ctx.strokeRect(bleed, bleed, w-2*bleed, h-2*bleed);

    // Safe box (inside trim)
    ctx.setLineDash([8, 8]);
    ctx.strokeStyle = "rgba(96,165,250,.55)";
    ctx.strokeRect(bleed+safe, bleed+safe, w-2*(bleed+safe), h-2*(bleed+safe));

    // Labels
    ctx.setLineDash([]);
    ctx.fillStyle = "rgba(255,255,255,.75)";
    ctx.font = `bold ${Math.max(18, Math.round(w*0.018))}px ${fontStack("system")}`;
    ctx.fillText("TRIM", bleed+10, bleed+24);
    ctx.fillStyle = "rgba(96,165,250,.85)";
    ctx.fillText("SAFE", bleed+safe+10, bleed+safe+24);
    ctx.restore();
  }

  // Simple vector icons for contacts (drawn)
  function drawIcon(ctx, kind, x, y, s, color){
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = Math.max(2, s*0.12);
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    const cx = x + s/2, cy = y + s/2;
    if(kind === "phone"){
      ctx.beginPath();
      ctx.arc(cx, cy, s*0.42, Math.PI*0.2, Math.PI*1.3);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x+s*0.25, y+s*0.7);
      ctx.lineTo(x+s*0.4, y+s*0.85);
      ctx.stroke();
    } else if(kind === "mail"){
      ctx.beginPath();
      roundedRect(ctx, x+s*0.12, y+s*0.2, s*0.76, s*0.6, s*0.12);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x+s*0.16, y+s*0.28);
      ctx.lineTo(cx, y+s*0.55);
      ctx.lineTo(x+s*0.84, y+s*0.28);
      ctx.stroke();
    } else if(kind === "web"){
      ctx.beginPath();
      ctx.arc(cx, cy, s*0.42, 0, Math.PI*2);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(cx, cy, s*0.20, 0, Math.PI*2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x+s*0.1, cy);
      ctx.lineTo(x+s*0.9, cy);
      ctx.moveTo(cx, y+s*0.1);
      ctx.lineTo(cx, y+s*0.9);
      ctx.stroke();
    } else if(kind === "pin"){
      ctx.beginPath();
      ctx.arc(cx, y+s*0.42, s*0.22, 0, Math.PI*2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(cx, y+s*0.64);
      ctx.lineTo(cx, y+s*0.92);
      ctx.stroke();
    } else if(kind === "linkedin"){
      ctx.beginPath();
      roundedRect(ctx, x+s*0.12, y+s*0.12, s*0.76, s*0.76, s*0.12);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x+s*0.30, y+s*0.44);
      ctx.lineTo(x+s*0.30, y+s*0.70);
      ctx.moveTo(x+s*0.30, y+s*0.30);
      ctx.arc(x+s*0.30, y+s*0.30, s*0.03, 0, Math.PI*2);
      ctx.moveTo(x+s*0.45, y+s*0.70);
      ctx.lineTo(x+s*0.45, y+s*0.50);
      ctx.quadraticCurveTo(x+s*0.52, y+s*0.40, x+s*0.62, y+s*0.50);
      ctx.lineTo(x+s*0.62, y+s*0.70);
      ctx.stroke();
    } else if(kind === "instagram"){
      ctx.beginPath();
      roundedRect(ctx, x+s*0.12, y+s*0.12, s*0.76, s*0.76, s*0.20);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(cx, cy, s*0.18, 0, Math.PI*2);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(x+s*0.68, y+s*0.32, s*0.04, 0, Math.PI*2);
      ctx.stroke();
    }
    ctx.restore();
  }

  // ========= QR generation (built-in, no libraries) =========
  // This is a light, self-contained QR implementation. It supports byte mode, ECC level M.
  // It’s not a full spec implementation for every edge-case, but works reliably for typical vCard + URL lengths.

  // ---- QR util: finite field + RS ECC ----
  const QR = (() => {
    // GF(256) tables with primitive polynomial 0x11d
    const EXP = new Uint8Array(512);
    const LOG = new Uint8Array(256);
    let x = 1;
    for (let i=0;i<255;i++){
      EXP[i] = x;
      LOG[x] = i;
      x <<= 1;
      if (x & 0x100) x ^= 0x11d;
    }
    for (let i=255;i<512;i++) EXP[i] = EXP[i-255];

    function gfMul(a,b){
      if (a===0 || b===0) return 0;
      return EXP[LOG[a]+LOG[b]];
    }

    function rsGeneratorPoly(deg){
      let poly = [1];
      for (let i=0;i<deg;i++){
        poly = polyMultiply(poly, [1, EXP[i]]);
      }
      return poly;
    }
    function polyMultiply(p, q){
      const out = new Array(p.length+q.length-1).fill(0);
      for (let i=0;i<p.length;i++){
        for (let j=0;j<q.length;j++){
          out[i+j] ^= gfMul(p[i], q[j]);
        }
      }
      return out;
    }
    function rsEncode(data, ecLen){
      const gen = rsGeneratorPoly(ecLen);
      const msg = data.slice();
      for (let i=0;i<ecLen;i++) msg.push(0);
      for (let i=0;i<data.length;i++){
        const coef = msg[i];
        if (coef !== 0){
          for (let j=0;j<gen.length;j++){
            msg[i+j] ^= gfMul(gen[j], coef);
          }
        }
      }
      return msg.slice(msg.length-ecLen);
    }

    // ---- Minimal QR builder: versions 1..4 in byte mode, ECC M ----
    // capacities (byte) for ECC M:
    // v1: 14, v2: 26, v3: 42, v4: 62 (approx for byte mode)
    const CAP = {
      1: { data: 16, ec: 10 }, // (codewords) total 26 -> data 16, ec 10
      2: { data: 28, ec: 16 }, // total 44
      3: { data: 44, ec: 26 }, // total 70
      4: { data: 64, ec: 36 }, // total 100
    };

    function chooseVersion(bytes){
      // very safe thresholds for byte-mode payload sizes
      if (bytes <= 14) return 1;
      if (bytes <= 26) return 2;
      if (bytes <= 42) return 3;
      if (bytes <= 62) return 4;
      return 4; // clamp; user should shorten
    }

    function makeMatrix(version){
      const size = 17 + 4*version;
      const m = Array.from({length:size}, ()=> new Array(size).fill(null));
      const reserved = Array.from({length:size}, ()=> new Array(size).fill(false));

      function set(x,y,val){
        if (x<0||y<0||x>=size||y>=size) return;
        m[y][x] = val;
        reserved[y][x] = true;
      }

      // Finder patterns
      function finder(x0,y0){
        for(let y=0;y<7;y++){
          for(let x=0;x<7;x++){
            const xx = x0+x, yy=y0+y;
            const on = (x===0||x===6||y===0||y===6)||(x>=2&&x<=4&&y>=2&&y<=4);
            set(xx,yy,on?1:0);
          }
        }
        // separators
        for(let i=-1;i<=7;i++){
          set(x0-1,y0+i,0);
          set(x0+7,y0+i,0);
          set(x0+i,y0-1,0);
          set(x0+i,y0+7,0);
        }
      }
      finder(0,0);
      finder(size-7,0);
      finder(0,size-7);

      // Timing patterns
      for(let i=8;i<size-8;i++){
        set(i,6, i%2===0 ? 1 : 0);
        set(6,i, i%2===0 ? 1 : 0);
      }

      // Dark module
      set(8, size-8, 1);

      // Reserve format info areas
      for(let i=0;i<9;i++){
        reserved[8][i]=true;
        reserved[i][8]=true;
      }
      for(let i=size-8;i<size;i++){
        reserved[8][i]=true;
        reserved[i][8]=true;
      }
      reserved[size-8][8]=true;

      // Alignment pattern for v2+
      function alignAt(cx,cy){
        for(let y=-2;y<=2;y++){
          for(let x=-2;x<=2;x++){
            const on = Math.max(Math.abs(x),Math.abs(y))===2 || (x===0 && y===0);
            set(cx+x, cy+y, on?1:0);
          }
        }
      }
      const ALIGN_POS = {
        1: [],
        2: [6, size-7],
        3: [6, Math.floor(size/2), size-7],
        4: [6, Math.floor(size/2), size-7],
      };
      const pos = ALIGN_POS[version];
      if (pos && pos.length){
        for (let i=0;i<pos.length;i++){
          for (let j=0;j<pos.length;j++){
            const cx = pos[i], cy = pos[j];
            // Skip overlaps with finders
            const inFinder =
              (cx<=8 && cy<=8) ||
              (cx>=size-9 && cy<=8) ||
              (cx<=8 && cy>=size-9);
            if (!inFinder) alignAt(cx,cy);
          }
        }
      }

      return {m, reserved, size};
    }

    function bytesFromString(str){
      // UTF-8
      return Array.from(new TextEncoder().encode(str));
    }

    function buildDataCodewords(payloadBytes, version){
      const cap = CAP[version];
      const dataCw = cap.data;

      // Mode indicator: 0100 (byte)
      // Count indicator: 8 bits for v1..9
      const bits = [];
      function pushBits(val, n){
        for(let i=n-1;i>=0;i--) bits.push((val>>i)&1);
      }
      pushBits(0b0100, 4);
      pushBits(payloadBytes.length, 8);
      for (const b of payloadBytes) pushBits(b, 8);

      // Terminator
      const maxBits = dataCw * 8;
      const remaining = maxBits - bits.length;
      if (remaining > 0) pushBits(0, Math.min(4, remaining));

      // Pad to byte boundary
      while (bits.length % 8 !== 0) bits.push(0);

      // Convert to codewords
      const codewords = [];
      for(let i=0;i<bits.length;i+=8){
        let cw=0;
        for(let j=0;j<8;j++) cw = (cw<<1) | bits[i+j];
        codewords.push(cw);
      }

      // Pad codewords
      const PAD0 = 0xEC, PAD1 = 0x11;
      let toggle = true;
      while (codewords.length < dataCw){
        codewords.push(toggle ? PAD0 : PAD1);
        toggle = !toggle;
      }
      return codewords;
    }

    // Place bits into matrix (standard zigzag)
    function placeData(matrixObj, allCodewords){
      const {m, reserved, size} = matrixObj;
      // Convert codewords to bit stream MSB first
      const bits = [];
      for(const cw of allCodewords){
        for(let i=7;i>=0;i--) bits.push((cw>>i)&1);
      }

      let bitIdx = 0;
      let dirUp = true;
      for (let x = size-1; x>0; x-=2){
        if (x === 6) x--; // skip timing column
        for (let yi=0; yi<size; yi++){
          const y = dirUp ? (size-1-yi) : yi;
          for (let dx=0; dx<2; dx++){
            const xx = x - dx;
            if (reserved[y][xx]) continue;
            m[y][xx] = bits[bitIdx++] ?? 0;
          }
        }
        dirUp = !dirUp;
      }
    }

    // Masking: we use mask 0 for simplicity (works fine). (i+j)%2==0
    function applyMask(matrixObj){
      const {m, reserved, size} = matrixObj;
      for(let y=0;y<size;y++){
        for(let x=0;x<size;x++){
          if (reserved[y][x]) continue;
          const mask = ((x + y) % 2) === 0;
          if (mask) m[y][x] ^= 1;
        }
      }
    }

    // Format info for ECC M + mask 0
    // ECC M: 00, mask 0: 000 => 00000
    // Precomputed final 15-bit format with BCH + XOR 0x5412:
    // for (M, mask 0) => 0b101010000010010 = 0x5412? actually that's the mask itself.
    // Correct format bits for (ECC M, mask 0) = 0x5412 ^ 0b00000???? (already includes xor).
    // The final 15-bit string is: 101010000010010 (commonly shown for M/0).
    const FORMAT_M0 = 0b101010000010010;

    function setFormat(matrixObj){
      const {m, size} = matrixObj;
      const bits = [];
      for(let i=14;i>=0;i--) bits.push((FORMAT_M0>>i)&1);

      // positions around top-left finder
      const coords1 = [
        [0,8],[1,8],[2,8],[3,8],[4,8],[5,8],[7,8],[8,8],
        [8,7],[8,5],[8,4],[8,3],[8,2],[8,1],[8,0]
      ];
      for(let i=0;i<15;i++){
        const [x,y] = coords1[i];
        m[y][x] = bits[i];
      }

      // top-right + bottom-left
      const coords2 = [
        [size-1,8],[size-2,8],[size-3,8],[size-4,8],[size-5,8],[size-6,8],[size-7,8],
        [8,size-8],[8,size-7],[8,size-6],[8,size-5],[8,size-4],[8,size-3],[8,size-2],[8,size-1]
      ];
      for(let i=0;i<15;i++){
        const [x,y] = coords2[i];
        m[y][x] = bits[i];
      }
    }

    function renderToCanvas(matrixObj, scale=6, margin=4, dark="#000", light="#fff"){
      const {m, size} = matrixObj;
      const out = document.createElement("canvas");
      out.width = (size + margin*2) * scale;
      out.height = (size + margin*2) * scale;
      const ctx = out.getContext("2d");
      ctx.fillStyle = light;
      ctx.fillRect(0,0,out.width,out.height);
      ctx.fillStyle = dark;
      for(let y=0;y<size;y++){
        for(let x=0;x<size;x++){
          if (m[y][x]) {
            ctx.fillRect((x+margin)*scale, (y+margin)*scale, scale, scale);
          }
        }
      }
      return out;
    }

    function makeQRCanvas(text, dark="#000", light="#fff"){
      const bytes = bytesFromString(text);
      const version = chooseVersion(bytes.length);
      const cap = CAP[version];

      // Build data + ECC
      const dataCw = buildDataCodewords(bytes, version);
      const ec = rsEncode(dataCw, cap.ec);
      const all = dataCw.concat(ec);

      const matrixObj = makeMatrix(version);
      placeData(matrixObj, all);
      applyMask(matrixObj);
      setFormat(matrixObj);

      // Render
      return renderToCanvas(matrixObj, 6, 4, dark, light);
    }

    return { makeQRCanvas };
  })();

  // ========= vCard / QR payload =========
  function vcardPayload(){
    const fn = safeText(els.name.value, 70);
    const org = safeText(els.company.value, 70);
    const title = safeText(els.title.value, 70);
    const tel = safeText(els.phone.value, 40);
    const email = safeText(els.email.value, 70);
    const url = safeText(ensureUrl(els.website.value), 120);
    const adr = safeText(els.address.value, 120);
    const li = safeText(ensureUrl(els.linkedin.value), 120);
    const igRaw = (els.instagram.value || "").trim();
    const ig = igRaw ? safeText(ensureUrl(`instagram.com/${igRaw.replace(/^@/,"")}`), 120) : "";

    // vCard 3.0 (widely compatible)
    const lines = [
      "BEGIN:VCARD",
      "VERSION:3.0",
      `FN:${fn}`,
      org ? `ORG:${org}` : "",
      title ? `TITLE:${title}` : "",
      tel ? `TEL;TYPE=CELL:${tel}` : "",
      email ? `EMAIL;TYPE=INTERNET:${email}` : "",
      url ? `URL:${url}` : "",
      li ? `URL;TYPE=LinkedIn:${li}` : "",
      ig ? `URL;TYPE=Instagram:${ig}` : "",
      adr ? `ADR;TYPE=WORK:;;${adr};;;;` : "",
      "END:VCARD"
    ].filter(Boolean);

    return lines.join("\n");
  }

  function qrText(){
    const mode = els.qrMode.value;
    if (mode === "off") return "";
    if (mode === "website"){
      return ensureUrl(els.website.value);
    }
    if (mode === "email"){
      const e = (els.email.value || "").trim();
      return e ? `mailto:${e}` : "";
    }
    if (mode === "phone"){
      const p = (els.phone.value || "").trim();
      return p ? `tel:${p}` : "";
    }
    if (mode === "vcard"){
      return vcardPayload();
    }
    return "";
  }

  function getQrCanvas(side){
    const txt = qrText();
    if (!txt) return null;
    const key = `${side}|${txt}|${els.qrSize.value}|${els.qrDark.value}|${els.qrLight.value}`;
    if (side === "front"){
      if (state.qrCache.keyFront === key && state.qrCache.front) return state.qrCache.front;
      const c = QR.makeQRCanvas(txt, els.qrDark.value, els.qrLight.value);
      state.qrCache.front = c;
      state.qrCache.keyFront = key;
      return c;
    } else {
      if (state.qrCache.keyBack === key && state.qrCache.back) return state.qrCache.back;
      const c = QR.makeQRCanvas(txt, els.qrDark.value, els.qrLight.value);
      state.qrCache.back = c;
      state.qrCache.keyBack = key;
      return c;
    }
  }

  // ========= Drawing templates =========
  function drawFront(){
    const c = els.frontCanvas;
    const ctx = c.getContext("2d");
    const dpi = +els.dpi.value;
    const sizeKey = els.size.value;
    const w = c.width, h = c.height;
    const exportMode = els.exportMode.value;
    const bleedIn = exportMode === "trimOnly" ? 0 : BLEED_IN;

    ctx.clearRect(0,0,w,h);
    state.hitRegions.front = [];

    // Background
    ctx.save();
    ctx.fillStyle = linearGradient(ctx, w, h, els.bg1.value, els.bg2.value);
    ctx.fillRect(0,0,w,h);

    // texture
    const texture = els.texture.value;
    if (texture === "soft"){
      ctx.globalAlpha = 0.10;
      ctx.fillStyle = els.accent.value;
      ctx.beginPath();
      ctx.ellipse(w*0.15, h*0.18, w*0.36, h*0.26, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(w*0.90, h*0.86, w*0.45, h*0.33, 0, 0, Math.PI*2);
      ctx.fill();
    } else if (texture === "mesh"){
      ctx.globalAlpha = 0.08;
      ctx.strokeStyle = els.accent.value;
      ctx.lineWidth = Math.max(1, Math.round(w*0.0025));
      const gap = Math.round(Math.min(w,h)*0.085);
      for(let x=0; x<w+gap; x+=gap){
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x - h*0.35, h);
        ctx.stroke();
      }
      for(let y=0; y<h+gap; y+=gap){
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y + w*0.35);
        ctx.stroke();
      }
    } else if (texture === "grid"){
      ctx.globalAlpha = 0.08;
      ctx.strokeStyle = els.accent.value;
      ctx.lineWidth = 1;
      const step = Math.max(10, Math.round(Math.min(w,h)*0.04));
      for(let x=0; x<w; x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
      for(let y=0; y<h; y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
    }
    ctx.restore();

    const bleed = px(bleedIn, dpi);
    const safe = px(SAFE_IN, dpi);
    const sx = bleed + safe;
    const sy = bleed + safe;
    const sw = w - 2*(bleed + safe);
    const sh = h - 2*(bleed + safe);

    const font = fontStack(els.font.value);
    const radius = +els.radius.value;

    // Layout measurements
    const layout = els.layout.value;

    const company = safeText(els.company.value, 32);
    const tagline = safeText(els.tagline.value, 44);
    const name = safeText(els.name.value, 32);
    const title = safeText(els.title.value, 44);

    // Typography sizes
    const companySize = Math.round(sw*(layout==="minimal" ? 0.065 : 0.070));
    const taglineSize = Math.round(sw*(layout==="minimal" ? 0.030 : 0.034));
    const nameSize = Math.round(sw*(layout==="centered" ? 0.080 : 0.075));
    const titleSize = Math.round(sw*0.040);
    const infoLabelSize = Math.round(sw*0.028);
    const infoValueSize = Math.round(sw*0.032);

    // Draw blocks depending on layout
    let infoX = sx, infoY = sy + sh*0.30;
    let textAlign = "left";
    if (layout === "split"){
      infoX = sx;
      infoY = sy + sh*0.52;
    }
    if (layout === "centered"){
      textAlign = "center";
      infoX = w/2;
    }

    // Company
    ctx.save();
    ctx.fillStyle = els.text.value;
    ctx.textAlign = textAlign;
    ctx.font = `900 ${companySize}px ${font}`;
    const companyPos = offsetPx("front.company", w, h);
    const companyX = infoX + companyPos.x;
    const companyY = sy + sh*(layout==="split" ? 0.22 : 0.20) + companyPos.y;
    ctx.fillText(company, companyX, companyY);
    const companyW = Math.max(40, ctx.measureText(company || "Company").width);
    addHit("front","front.company", companyX - (textAlign==="center" ? companyW/2 : 0), companyY - companySize, companyW, companySize + 10);

    // Tagline
    ctx.fillStyle = "rgba(229,231,235,.82)";
    ctx.font = `700 ${taglineSize}px ${font}`;
    const tagPos = offsetPx("front.tagline", w, h);
    const tagX = infoX + tagPos.x;
    const tagY = sy + sh*(layout==="split" ? 0.31 : 0.29) + tagPos.y;
    if (tagline) {
      ctx.fillText(tagline, tagX, tagY);
      const tagW = Math.max(40, ctx.measureText(tagline).width);
      addHit("front","front.tagline", tagX - (textAlign==="center" ? tagW/2 : 0), tagY - taglineSize, tagW, taglineSize + 10);
    }
    ctx.restore();

    // Name + title
    ctx.save();
    ctx.fillStyle = els.text.value;
    ctx.textAlign = textAlign;
    ctx.font = `900 ${nameSize}px ${font}`;
    const namePos = offsetPx("front.name", w, h);
    const nameX = infoX + namePos.x;
    const nameY = sy + sh*(layout==="centered" ? 0.52 : (layout==="split" ? 0.44 : 0.54)) + namePos.y;
    ctx.fillText(name || "Your Name", nameX, nameY);
    const nameW = Math.max(40, ctx.measureText(name || "Your Name").width);
    addHit("front","front.name", nameX - (textAlign==="center" ? nameW/2 : 0), nameY - nameSize, nameW, nameSize + 10);

    ctx.fillStyle = "rgba(229,231,235,.80)";
    ctx.font = `800 ${titleSize}px ${font}`;
    const titlePos = offsetPx("front.title", w, h);
    const titleX = infoX + titlePos.x;
    const titleY = nameY + sh*0.10 + titlePos.y;
    ctx.fillText(title || "Your Title", titleX, titleY);
    const titleW = Math.max(40, ctx.measureText(title || "Your Title").width);
    addHit("front","front.title", titleX - (textAlign==="center" ? titleW/2 : 0), titleY - titleSize, titleW, titleSize + 10);
    ctx.restore();

    // Contact list
    const items = [
      ["PHONE", (els.phone.value||"").trim(), "phone"],
      ["EMAIL", (els.email.value||"").trim(), "mail"],
      ["WEB", (els.website.value||"").trim(), "web"],
      ["ADDR", (els.address.value||"").trim(), "pin"],
      ["LINKEDIN", (els.linkedin.value||"").trim(), "linkedin"],
      ["INSTAGRAM", (els.instagram.value||"").trim(), "instagram"],
    ].filter(x => x[1].length);

    ctx.save();
    ctx.textAlign = "left";
    const baseX = layout==="centered" ? (sx + sw*0.10) : sx;
    const baseY = sy + sh*(layout==="split" ? 0.68 : 0.74);
    const lineH = Math.round(sh*0.075);
    items.forEach((it, i) => {
      const contactPos = offsetPx(`front.contact${i}`, w, h);
      const localBaseX = baseX + contactPos.x;
      const y = baseY + i*lineH + contactPos.y;
      const label = it[0];
      const val = it[1];
      const iconKind = it[2];

      const padX = Math.round(sw*0.018);
      const pillH = Math.round(sw*0.052);
      ctx.font = `900 ${infoLabelSize}px ${font}`;
      const labelW = ctx.measureText(label).width + padX*2;

      // label pill
      ctx.save();
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = "rgba(255,255,255,.08)";
      roundedRect(ctx, localBaseX, y - pillH + 6, labelW, pillH, 999);
      ctx.fill();
      ctx.restore();

      // icon
      const iconsOn = els.icons.value === "on";
      const iconSize = Math.round(pillH*0.66);
      const iconX = localBaseX + labelW + Math.round(sw*0.018);
      const iconY = y - iconSize + 3;
      if (iconsOn){
        drawIcon(ctx, iconKind, iconX, iconY, iconSize, "rgba(229,231,235,.75)");
      }

      // label
      ctx.fillStyle = els.accent.value;
      ctx.fillText(label, localBaseX + padX, y);

      // value
      ctx.fillStyle = "rgba(229,231,235,.88)";
      ctx.font = `800 ${infoValueSize}px ${font}`;
      const valueX = iconsOn ? (iconX + iconSize + Math.round(sw*0.012)) : (localBaseX + labelW + Math.round(sw*0.02));
      ctx.fillText(val, valueX, y);
      const rowW = Math.max(80, (valueX - localBaseX) + ctx.measureText(val).width + 8);
      addHit("front", `front.contact${i}`, localBaseX, y - pillH, rowW, pillH + 12);
    });
    ctx.restore();

    // Logo
    drawLogo(ctx, w, h, radius);

    // QR (optional) on front
    if (els.qrOnBack.value === "front"){
      drawQR(ctx, "front", w, h, radius);
    }

    drawGuides(ctx, w, h, dpi);

    // keep back synced
    drawBack();
  }

  function drawLogo(ctx, w, h, radius){
    if (!state.logoImg) {
      // placeholder mark
      ctx.save();
      const r = Math.min(w,h)*0.085;
      ctx.globalAlpha = 0.75;
      ctx.fillStyle = "rgba(255,255,255,.10)";
      ctx.beginPath();
      ctx.arc(w*0.80, h*0.28, r, 0, Math.PI*2);
      ctx.fill();

      ctx.globalAlpha = 0.95;
      ctx.fillStyle = els.accent.value;
      ctx.font = `900 ${Math.round(r*0.72)}px ${fontStack(els.font.value)}`;
      const px = w*0.80 - r*0.55;
      const py = h*0.28 + r*0.25;
      ctx.fillText("LL", px, py);
      addHit("front","front.logo", w*0.80-r, h*0.28-r, r*2, r*2, "logo");
      ctx.restore();
      return;
    }

    const img = state.logoImg;
    const targetW = w * state.logoScale;
    const aspect = img.width / img.height;
    const targetH = targetW / aspect;

    const cx = w * state.logoPos.x;
    const cy = h * state.logoPos.y;
    const x = cx - targetW/2;
    const y = cy - targetH/2;

    if (els.logoMode.value === "plate"){
      ctx.save();
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = "rgba(0,0,0,.28)";
      roundedRect(ctx, x - 12, y - 12, targetW + 24, targetH + 24, Math.max(14, radius));
      ctx.fill();

      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = "rgba(255,255,255,.12)";
      ctx.lineWidth = 2;
      roundedRect(ctx, x - 12, y - 12, targetW + 24, targetH + 24, Math.max(14, radius));
      ctx.stroke();
      ctx.restore();
    }

    ctx.drawImage(img, x, y, targetW, targetH);
    addHit("front","front.logo", x-14, y-14, targetW+28, targetH+28, "logo");
  }

  function drawQR(ctx, side, w, h, radius){
    const txt = qrText();
    if (!txt) return;

    // make a qr canvas
    const qr = getQrCanvas(side);
    if (!qr) return;

    const scaleFrac = +els.qrSize.value;
    const sizePx = Math.round(Math.min(w,h) * scaleFrac);

    const pad = Math.round(Math.min(w,h) * 0.045);
    const qrPos = offsetPx(`${side}.qr`, w, h);
    const x = w - pad - sizePx + qrPos.x;
    const y = h - pad - sizePx + qrPos.y;

    // plate with contrast
    const bg = els.qrLight.value;

    ctx.save();
    // QR plate
    ctx.globalAlpha = 0.94;
    ctx.fillStyle = "rgba(0,0,0,.22)";
    roundedRect(ctx, x - 10, y - 10, sizePx + 20, sizePx + 20, Math.max(12, radius));
    ctx.fill();

    ctx.globalAlpha = 1;
    ctx.fillStyle = bg;
    roundedRect(ctx, x - 6, y - 6, sizePx + 12, sizePx + 12, Math.max(10, radius));
    ctx.fill();

    // draw qr scaled
    ctx.drawImage(qr, 0, 0, qr.width, qr.height, x, y, sizePx, sizePx);

    // label
    const label = (els.qrLabel.value || "").trim();
    if (label){
      ctx.fillStyle = "rgba(229,231,235,.85)";
      ctx.font = `800 ${Math.round(w*0.022)}px ${fontStack(els.font.value)}`;
      ctx.textAlign = "right";
      ctx.fillText(label, x + sizePx, y - Math.round(w*0.02));
      ctx.textAlign = "left";
    }
    addHit(side, `${side}.qr`, x-10, y-10, sizePx+20, sizePx+20);
    ctx.restore();
  }

  function drawBack(){
    const c = els.backCanvas;
    const ctx = c.getContext("2d");
    const dpi = +els.dpi.value;
    const w = c.width, h = c.height;

    ctx.clearRect(0,0,w,h);
    state.hitRegions.back = [];

    // Background
    ctx.fillStyle = linearGradient(ctx, w, h, els.bg2.value, els.bg1.value);
    ctx.fillRect(0,0,w,h);

    const font = fontStack(els.font.value);
    const radius = +els.radius.value;
    const backStyle = els.backStyle.value;

    if (backStyle === "ring"){
      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.strokeStyle = els.accent.value;
      ctx.lineWidth = Math.max(8, Math.round(w*0.016));
      ctx.beginPath();
      ctx.arc(w*0.5, h*0.42, Math.min(w,h)*0.18, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    } else if (backStyle === "stripe"){
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = els.accent.value;
      ctx.translate(w*0.15, -h*0.35);
      ctx.rotate(-0.28);
      roundedRect(ctx, 0, 0, w*0.7, h*1.6, Math.round(w*0.06));
      ctx.fill();
      ctx.restore();
    }

    // Logo centered or placeholder
    if (state.logoImg){
      const img = state.logoImg;
      const maxW = w*0.34;
      const aspect = img.width / img.height;
      const hh = maxW / aspect;
      const logoPos = offsetPx("back.logo", w, h);
      const lx = w*0.5 - maxW/2 + logoPos.x;
      const ly = h*0.42 - hh/2 + logoPos.y;

      if (els.logoMode.value === "plate"){
        ctx.save();
        ctx.globalAlpha = 0.85;
        ctx.fillStyle = "rgba(0,0,0,.22)";
        roundedRect(ctx, lx - 12, ly - 12, maxW + 24, hh + 24, Math.max(14, radius));
        ctx.fill();
        ctx.restore();
      }

      ctx.drawImage(img, lx, ly, maxW, hh);
      addHit("back","back.logo", lx-14, ly-14, maxW+28, hh+28, "offset");
    } else {
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,.12)";
      ctx.beginPath();
      ctx.arc(w*0.5, h*0.42, Math.min(w,h)*0.14, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = els.text.value;
      ctx.font = `900 ${Math.round(w*0.08)}px ${font}`;
      ctx.textAlign = "center";
      ctx.fillText("LOGO", w*0.5, h*0.44);
      ctx.textAlign = "left";
      ctx.restore();
    }

    // Company + tagline
    ctx.save();
    ctx.textAlign = "center";
    ctx.fillStyle = els.backCompanyColor.value;
    const companyY = backStyle === "minimal" ? h*0.52 : h*0.70;
    const taglineY = backStyle === "minimal" ? h*0.60 : h*0.78;
    const websiteY = backStyle === "minimal" ? h*0.70 : h*0.88;
    const companySize = backStyle === "minimal" ? 0.075 : 0.06;
    const tagSize = backStyle === "minimal" ? 0.036 : 0.028;
    const webSize = backStyle === "minimal" ? 0.040 : 0.03;
    ctx.font = `900 ${Math.round(w*companySize)}px ${font}`;
    const backCompanyPos = offsetPx("back.company", w, h);
    const companyX = w*0.5 + backCompanyPos.x;
    const companyY2 = companyY + backCompanyPos.y;
    const companyTxt = safeText(els.company.value, 32) || "Company";
    ctx.fillText(companyTxt, companyX, companyY2);
    const compW = Math.max(40, ctx.measureText(companyTxt).width);
    addHit("back","back.company", companyX - compW/2, companyY2 - Math.round(w*companySize), compW, Math.round(w*companySize) + 10);

    ctx.fillStyle = els.backTaglineColor.value;
    ctx.font = `800 ${Math.round(w*tagSize)}px ${font}`;
    const tag = safeText(els.tagline.value, 50);
    if (tag) {
      const backTagPos = offsetPx("back.tagline", w, h);
      const tx = w*0.5 + backTagPos.x;
      const ty = taglineY + backTagPos.y;
      ctx.fillText(tag, tx, ty);
      const tw = Math.max(40, ctx.measureText(tag).width);
      addHit("back","back.tagline", tx - tw/2, ty - Math.round(w*tagSize), tw, Math.round(w*tagSize) + 10);
    }

    // Website
    const web = (els.website.value || "").trim();
    if (web){
      ctx.fillStyle = els.backWebsiteColor.value;
      ctx.font = `900 ${Math.round(w*webSize)}px ${font}`;
      const backWebPos = offsetPx("back.website", w, h);
      const wx = w*0.5 + backWebPos.x;
      const wy = websiteY + backWebPos.y;
      ctx.fillText(web, wx, wy);
      const ww = Math.max(40, ctx.measureText(web).width);
      addHit("back","back.website", wx - ww/2, wy - Math.round(w*webSize), ww, Math.round(w*webSize) + 10);
    }

    // Back bullets
    const bulletLines = (els.backBullets.value || "")
      .split(/\r?\n/)
      .map(s=>s.trim())
      .filter(Boolean)
      .slice(0,6);
    if (bulletLines.length){
      const bulletPos = offsetPx("back.bullets", w, h);
      const startX = w*0.18 + bulletPos.x;
      let startY = h*0.58 + bulletPos.y;
      const lh = Math.round(h*0.08);
      const bFont = Math.round(w*0.026);
      ctx.fillStyle = els.backBulletColor.value;
      ctx.font = `700 ${bFont}px ${font}`;
      let maxW = 0;
      bulletLines.forEach(line=>{
        ctx.fillStyle = els.backBulletDotColor.value;
        ctx.beginPath();
        ctx.arc(startX, startY - bFont*0.35, Math.max(3, bFont*0.15), 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = els.backBulletColor.value;
        ctx.fillText(line, startX + 16, startY);
        maxW = Math.max(maxW, ctx.measureText(line).width + 22);
        startY += lh;
      });
      addHit("back","back.bullets", startX - 6, h*0.58 + bulletPos.y - bFont, maxW + 16, lh * bulletLines.length + 8);
    }
    ctx.restore();

    // QR (optional) on back
    if (els.qrOnBack.value === "back"){
      drawQR(ctx, "back", w, h, radius);
    }

    drawGuides(ctx, w, h, dpi);

    // Disabled overlay
    if (!els.backSide.checked){
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.fillRect(0,0,w,h);
      ctx.fillStyle = "rgba(255,255,255,.85)";
      ctx.font = `900 ${Math.round(w*0.04)}px ${fontStack("system")}`;
      ctx.textAlign = "center";
      ctx.fillText("Back side disabled", w/2, h/2);
      ctx.textAlign = "left";
      ctx.restore();
    }
  }

  function redrawAll(){
    // status
    const hasQRCode = els.qrMode.value !== "off";
    const hasBack = els.backSide.checked;
    els.statusPill.textContent = hasQRCode ? "QR enabled" : (hasBack ? "Back enabled" : "Ready");
    setupCanvases();
    drawFront();
  }

  // ========= Downloads =========
  function downloadCanvas(canvas, filename){
    const a = document.createElement("a");
    a.download = filename;
    a.href = canvas.toDataURL("image/png");
    a.click();
  }
  function snapshotCard(side){
    const oldGuides = !!els.guides.checked;
    els.guides.checked = false;
    drawFront();
    const src = side === "back" ? els.backCanvas : els.frontCanvas;
    const snap = document.createElement("canvas");
    snap.width = src.width;
    snap.height = src.height;
    snap.getContext("2d").drawImage(src, 0, 0);
    els.guides.checked = oldGuides;
    drawFront();
    return snap;
  }

  // ========= Drag / move elements =========
  function getCanvasPos(canvas, evt){
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * (canvas.width / rect.width);
    const y = (evt.clientY - rect.top) * (canvas.height / rect.height);
    return {x,y};
  }
  function findHit(side, x, y){
    const list = state.hitRegions[side] || [];
    for(let i=list.length-1; i>=0; i--){
      const r = list[i];
      if(x >= r.x && x <= r.x + r.w && y >= r.y && y <= r.y + r.h) return r;
    }
    return null;
  }
  function pointerDownOnCanvas(side, canvas, e){
    const p = getCanvasPos(canvas, e);
    const hit = findHit(side, p.x, p.y);
    if(!hit) return;
    state.dragging = true;
    state.dragRegion = hit;
    state.dragCanvas = canvas;
    state.dragStart = { x: p.x, y: p.y };
    canvas.setPointerCapture?.(e.pointerId);
    e.preventDefault();
  }
  function pointerMoveGlobal(e){
    if(!state.dragging || !state.dragRegion || !state.dragCanvas) return;
    const p = getCanvasPos(state.dragCanvas, e);
    const dx = p.x - state.dragStart.x;
    const dy = p.y - state.dragStart.y;
    const w = state.dragCanvas.width || 1;
    const h = state.dragCanvas.height || 1;
    const speed = e.shiftKey ? 1.8 : 1;

    if(state.dragRegion.type === "logo" && state.dragRegion.key === "front.logo"){
      state.logoPos.x = clamp(state.logoPos.x + (dx / w) * speed, 0.02, 0.98);
      state.logoPos.y = clamp(state.logoPos.y + (dy / h) * speed, 0.02, 0.98);
      localStorage.setItem("bc_logo_pos_v2", JSON.stringify(state.logoPos));
    } else {
      const pos = ensurePos(state.dragRegion.key);
      pos.x = clamp(pos.x + (dx / w) * speed, -0.45, 0.45);
      pos.y = clamp(pos.y + (dy / h) * speed, -0.45, 0.45);
    }
    state.dragStart = { x: p.x, y: p.y };
    drawFront();
  }
  function pointerUpGlobal(){
    state.dragging = false;
    state.dragRegion = null;
    state.dragCanvas = null;
  }
  function updateCanvasCursor(side, canvas, e){
    const p = getCanvasPos(canvas, e);
    const hit = findHit(side, p.x, p.y);
    canvas.style.cursor = hit ? "grab" : "default";
  }

  els.frontCanvas.addEventListener("pointerdown", (e)=> pointerDownOnCanvas("front", els.frontCanvas, e));
  els.backCanvas.addEventListener("pointerdown", (e)=> pointerDownOnCanvas("back", els.backCanvas, e));
  window.addEventListener("pointermove", pointerMoveGlobal);
  window.addEventListener("pointerup", pointerUpGlobal);
  els.frontCanvas.addEventListener("pointermove", (e)=> updateCanvasCursor("front", els.frontCanvas, e));
  els.backCanvas.addEventListener("pointermove", (e)=> updateCanvasCursor("back", els.backCanvas, e));

  function handleLogoWheel(side, canvas, e){
    const p = getCanvasPos(canvas, e);
    const hit = findHit(side, p.x, p.y);
    if(!hit || !hit.key.includes("logo")) return;
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    state.logoScale = clamp(state.logoScale + delta * 0.015, 0.10, 0.42);
    drawFront();
  }
  els.frontCanvas.addEventListener("wheel", (e)=> handleLogoWheel("front", els.frontCanvas, e), { passive:false });
  els.backCanvas.addEventListener("wheel", (e)=> handleLogoWheel("back", els.backCanvas, e), { passive:false });

  // ========= Logo upload =========
  els.logo.addEventListener("change", (e) => {
    const file = e.target.files && e.target.files[0];
    if(!file) return;

    // SVG handling: render into an Image via blob URL (works in most browsers)
    const img = new Image();
    img.onload = () => {
      state.logoImg = img;
      toast("ok","Logo loaded","Drag it on the card.");
      drawFront();
    };
    img.onerror = () => toast("warn","Logo error","Try PNG/JPG if SVG fails in your browser.");
    img.src = URL.createObjectURL(file);
  });

  // ========= Save / load preset =========
  const PRESET_KEY = "bc_preset_v2";

  function savePreset(){
    const cfg = getConfig();
    localStorage.setItem(PRESET_KEY, JSON.stringify(cfg));
    toast("ok","Preset saved","Stored in this browser.");
  }

  function loadPreset(){
    const raw = localStorage.getItem(PRESET_KEY);
    if(!raw){
      toast("warn","No preset found","Save one first.");
      return;
    }
    try{
      const cfg = JSON.parse(raw);
      setConfig(cfg);
      toast("ok","Preset loaded","Applied settings.");
    }catch{
      toast("warn","Preset corrupted","Reset and save again.");
    }
  }

  // ========= Actions =========
  function exportFront(){
    const base = (els.fileName.value || "business-card").trim().replace(/\s+/g,"-");
    downloadCanvas(snapshotCard("front"), `${base}-front.png`);
    toast("ok","Exported","Front PNG downloaded.");
  }

  function exportBack(){
    if(!els.backSide.checked){
      toast("warn","Back disabled","Enable back side first.");
      return;
    }
    const base = (els.fileName.value || "business-card").trim().replace(/\s+/g,"-");
    downloadCanvas(snapshotCard("back"), `${base}-back.png`);
    toast("ok","Exported","Back PNG downloaded.");
  }

  function downloadVcf(){
    const payload = vcardPayload();
    const blob = new Blob([payload], { type: "text/vcard;charset=utf-8" });
    const a = document.createElement("a");
    const base = (els.fileName.value || "business-card").trim().replace(/\s+/g,"-");
    a.download = `${base}.vcf`;
    a.href = URL.createObjectURL(blob);
    a.click();
    URL.revokeObjectURL(a.href);
    toast("ok","vCard exported","Contact file downloaded.");
  }

  function exportSheet(){
    const sheetDpi = +els.sheetDpi.value || 300;
    const sheetW = px(8.27, sheetDpi); // A4
    const sheetH = px(11.69, sheetDpi);
    const margin = px(0.35, sheetDpi);
    const gap = px(0.2, sheetDpi);
    const side = els.sheetSide.value === "both" ? "both" : (els.sheetSide.value === "back" ? "back" : "front");
    if ((side === "back" || side === "both") && !els.backSide.checked){
      toast("warn","Back disabled","Enable back side first.");
      return;
    }

    const cols = 2;
    const rows = 5;
    const usableW = sheetW - margin*2 - gap*(cols-1);
    const usableH = sheetH - margin*2 - gap*(rows-1);
    const cardW = Math.floor(usableW / cols);
    const cardH = Math.floor(usableH / rows);

    const makeSheet = (cardSide) => {
      const source = snapshotCard(cardSide);
      const sheet = document.createElement("canvas");
      sheet.width = sheetW;
      sheet.height = sheetH;
      const ctx = sheet.getContext("2d");
      ctx.fillStyle = "#fff";
      ctx.fillRect(0,0,sheetW,sheetH);

      for(let r=0; r<rows; r++){
        for(let c=0; c<cols; c++){
          const x = margin + c*(cardW + gap);
          const y = margin + r*(cardH + gap);
          ctx.drawImage(source, 0, 0, source.width, source.height, x, y, cardW, cardH);
          ctx.strokeStyle = "rgba(0,0,0,.25)";
          ctx.lineWidth = 1;
          ctx.strokeRect(x, y, cardW, cardH);
        }
      }
      return sheet;
    };

    const base = (els.fileName.value || "business-card").trim().replace(/\s+/g,"-");
    if (side === "both"){
      downloadCanvas(makeSheet("front"), `${base}-sheet-front-a4.png`);
      setTimeout(()=> downloadCanvas(makeSheet("back"), `${base}-sheet-back-a4.png`), 120);
      toast("ok","Sheets exported","Front + back A4 sheets downloaded.");
    } else {
      downloadCanvas(makeSheet(side), `${base}-sheet-${side}-a4.png`);
      toast("ok","Sheet exported","A4 print sheet downloaded.");
    }
  }

  function resetAll(){
    // Defaults
    els.size.value = "us";
    els.dpi.value = "300";
    els.company.value = "Your Company Name";
    els.tagline.value = "Your Service Tagline";
    els.name.value = "Your Full Name";
    els.title.value = "Your Role / Title";
    els.phone.value = "+1 (555) 123-4567";
    els.email.value = "hello@yourdomain.com";
    els.website.value = "yourcompany.com";
    els.address.value = "City, State / Country";
    els.backBullets.value = "Primary Service 01\nPrimary Service 02\nPrimary Service 03\nPrimary Service 04";
    els.linkedin.value = "linkedin.com/in/yourprofile";
    els.instagram.value = "@yourhandle";

    els.layout.value = "classic";
    els.icons.value = "on";

    els.font.value = "system";
    els.radius.value = "18";

    els.bg1.value = "#0b1020";
    els.bg2.value = "#111827";
    els.accent.value = "#60a5fa";
    els.text.value = "#e5e7eb";
    els.preset.value = "custom";
    els.texture.value = "soft";
    els.backStyle.value = "ring";
    els.backCompanyColor.value = "#e5e7eb";
    els.backTaglineColor.value = "#cbd5e1";
    els.backWebsiteColor.value = "#60a5fa";
    els.backBulletColor.value = "#e5e7eb";
    els.backBulletDotColor.value = "#60a5fa";

    els.guides.checked = true;
    els.backSide.checked = false;

    els.logoMode.value = "plate";
    state.logoImg = null;
    state.logoPos = { x: 0.77, y: 0.24 };
    state.logoScale = 0.22;
    state.positions = {};
    localStorage.removeItem("bc_logo_pos_v2");
    els.logo.value = "";

    els.qrMode.value = "off";
    els.qrSize.value = "0.24";
    els.qrLabel.value = "Scan to save contact";
    els.qrOnBack.value = "front";
    els.qrDark.value = "#000000";
    els.qrLight.value = "#ffffff";

    els.exportMode.value = "withBleed";
    els.fileName.value = "business-card";
    els.sheetSide.value = "front";
    els.sheetDpi.value = "300";

    // clear qr cache
    state.qrCache = { front: null, back: null, keyFront: "", keyBack: "" };

    setupCanvases();
    drawFront();
    toast("ok","Reset done","Back to defaults.");
  }

  // ========= Inputs -> redraw =========
  const redrawIds = [
    "company","tagline","name","title","phone","email","website","address","backBullets",
    "linkedin","instagram",
    "layout","icons",
    "size","dpi","font","radius","bg1","bg2","accent","text","preset","texture","backStyle","backCompanyColor","backTaglineColor","backWebsiteColor","backBulletColor","backBulletDotColor","guides","backSide","exportMode",
    "logoMode",
    "qrMode","qrSize","qrLabel","qrOnBack","qrDark","qrLight",
    "fileName","sheetSide","sheetDpi"
  ];

  redrawIds.forEach(id=>{
    const el = $(id);
    if(!el) return;
    el.addEventListener("input", () => {
      if (id === "preset") return;
      if (id === "size" || id === "dpi" || id === "exportMode") setupCanvases();
      if (id.startsWith("qr")) { state.qrCache = { front:null, back:null, keyFront:"", keyBack:"" }; }
      drawFront();
    });
    el.addEventListener("change", () => {
      if (id === "size" || id === "dpi" || id === "exportMode") setupCanvases();
      if (id.startsWith("qr")) { state.qrCache = { front:null, back:null, keyFront:"", keyBack:"" }; }
      drawFront();
    });
  });

  els.preset.addEventListener("change", () => {
    const v = els.preset.value;
    if (v === "custom") return;
    applyPreset(v);
    els.preset.value = "custom";
  });

  // Buttons
  els.downloadFront.addEventListener("click", exportFront);
  els.downloadBack.addEventListener("click", exportBack);
  els.downloadVcf.addEventListener("click", downloadVcf);
  els.exportSheet.addEventListener("click", exportSheet);
  els.downloadFrontTop.addEventListener("click", exportFront);
  els.copyLink.addEventListener("click", copyShareLink);
  els.savePreset.addEventListener("click", savePreset);
  els.loadPreset.addEventListener("click", loadPreset);
  els.savePresetPanel.addEventListener("click", savePreset);
  els.loadPresetPanel.addEventListener("click", loadPreset);
  els.reset.addEventListener("click", resetAll);

  // ========= Help modal =========
  function openHelp(){
    els.helpModal.classList.add("open");
    els.helpModal.setAttribute("aria-hidden","false");
  }
  function closeHelp(){
    els.helpModal.classList.remove("open");
    els.helpModal.setAttribute("aria-hidden","true");
  }
  els.openHelp.addEventListener("click", openHelp);
  els.closeHelp.addEventListener("click", closeHelp);
  els.helpModal.addEventListener("click", (e) => {
    if (e.target === els.helpModal) closeHelp();
  });

  // ========= Keyboard shortcuts =========
  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape") closeHelp();
    const ctrl = e.ctrlKey || e.metaKey;
    if (!ctrl) return;
    if (e.key.toLowerCase() === "s"){
      e.preventDefault(); savePreset();
    }
    if (e.key.toLowerCase() === "o"){
      e.preventDefault(); loadPreset();
    }
    if (e.key.toLowerCase() === "e"){
      e.preventDefault(); exportFront();
    }
  });

  // ========= Share link load =========
  const url = new URL(window.location.href);
  const cParam = url.searchParams.get("c");
  if (cParam){
    const cfg = decodeShare(cParam);
    if (cfg){
      setConfig(cfg);
      toast("ok","Loaded from link","Settings applied.");
    }
  }

  // ========= Init =========
  setupCanvases();
  drawFront();
})();
</script>
</body>
</html>
